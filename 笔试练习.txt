数据库的三范式是：
第一范式（ 1NF ）： 字段具有 原子性 , 不可再分 。所有关系型数据库系统都满足第一范式）数据库表中的字段都是单一属性的，不可再分。例如，姓名字段，其中的姓和名必须作为一个整体，无法区分哪部分是姓，哪部分是名，如果要区分出姓和名，必须设计成两个独立的字段。

第二范式（ 2NF ）： 第二范式（ 2NF ）是在 第一范式（ 1NF ）的基础上 建立起来的，即满足第二范式（ 2NF ）必须先满足第一范式（ 1NF ）。要求 数据库表中的每个实例或行必须可以被惟一地区分 。通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为 主关键字或主键 。
     第二范式（ 2NF ）要求 实体的属性完全依赖于主关键字 。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。简而言之，第二范式就是非主属性非部分依赖于主关键字。

第三范式的要求如下： 满足第三范式（ 3NF ） 必须先满足第二范式（ 2NF ） 。简而言之，第三范式（ 3NF ）要求一个数据库表中 不包含 已在其它表中 已包含的非主关键字信息 。所以第三范式具有如下特征：
1 ，每一列只有一个值
2 ，每一行都能区分。
3 ，每一个表都 不包含其他表已经包含 的非主关键字信息。

例如，帖子表中只能出现发帖人的 id ，而不能出现发帖人的 id ，还同时出现发帖人姓名，否则，只要出现同一发帖人 id 的所有记录，它们中的姓名部分都必须严格保持一致，这就是 数据冗余 

strcpy和strncpy用法和区别

1. strcpy函数：顾名思义字符串复制函数：
原型：extern char *strcpy(char *dest,char *src); 
功能：把从src地址开始且含有NULL结束符的字符串赋值到以dest开始的地址空间，返回dest（地址中存储的为复制后的新值）。
要求：src和dest所指内存区域不可以重叠且dest必须有足够的空间来容纳src的字符串。

2. strncpy函数：多个n代表可以指定字符个数进行赋值。
原型：char * strncpy(char *dest, char *src, size_tn);  
功能：将字符串src中最多n个字符复制到字符数组dest中(它并不像strcpy一样遇到NULL才停止复制，而是等凑够n个字符才开始复制），返回指向dest的指针。
要求：如果n > dest串长度，dest栈空间溢出产生崩溃异常。该函数注意的地方和strcpy类似，但是n值需特别注意，
strcpy、strncpy与memcpy的区别与使用方法
strcpy、strncpy、memcpy这三个C语言函数我们在主机代码编写中会很频繁的使用到，但是三个函数的区别、使用时该注意什么还是有必要说下的。




1、memcpy函数
void  *memcpy(void *s1,  const void *s2,  size_t  n);
说明：函数memcpy从s2指向的对象中复制n个字符到s1指向的对象中。如果复制发生在两个重叠的对象中，则这种行为未定义。
返回值：函数memcpy返回s1的值。

2、strcpy函数
char  *strcpy(char *s2, const char *s1);
说明：函数strcpy把s1指向的串（包括空字符）复制到s2指向的数组中。如果复制发生在两个重叠的对象中，则这种行为未定义。
返回值：函数strcpy返回s2的值。

3、strncpy函数
char  *strncpy(char *s2, const char *s1, size_t n);
说明：函数strncpy从s1指向的数组中最多复制n个字符（不复制空字符后面的字符）到s2指向的数组中。如果复制发生在两个重叠的对象中，则这种行为未定义。
如果s1指向的数组是一个比n短的字符串，则在s2定义的数组后面补空字符，直到写入了n个字符。
返回值：函数strncpy返回s2的值。

二、注意事项
strcpy 是依据 “\0” 作为结束判断的，如果 s2 的空间不够，则会引起 buffer overflow。
memcpy用来在内存中复制数据，由于字符串是以“\0”结尾的，所以对于在数据中包含“\0”的数据只能用memcpy，如:"hell\0oworld"。
strncpy和memcpy很相似，只不过它在一个终止的空字符处停止。当n>strlen(s1)时，给s2不够数的空间里填充“\0”；当n<=strlen(s1)时，s2是没有结束符“\0”的。
这里隐藏了一个事实，就是s2指向的内存一定会被写n个字符。

所以总的来说注意：
1、s2指向的空间要足够拷贝；使用strcpy时，s2指向的空间要大于等于s1指向的空间；使用strncpy或memcpy时，s2指向的空间要大于或等于n。
2、使用strncpy或memcpy时，n应该大于strlen(s1)，或者说最好n >= strlen(s1)+1；这个1 就是最后的“\0”。
3、使用strncpy时，确保s2的最后一个字符是“\0”。

倒V模型按软件生命周期共分为10个阶段，
分别为：需求搜集；需求分析；系统分析；概要设计；详细设计；编码和单元测试；
组件测试；集成测试；系统测试；验收

无向图G的极大连通子图称为G的连通分量( Connected Component)。任何连通图的连通分量只有一个，即是其自身，非连通的无向图有多个连通分量。

根据“最长前缀匹配原则”169.96.40.5与169.96.40.0前27位匹配最长

sleep()方法强制使当前线程休眠，释放CPU资源，以便使得其他所有线程有机会运行。
yield()方法使得当前的线程让出CPU的使用权，以使得比该线程优先级相同或更高的线程有机会运行。该线程在让出CPU使用权之后可能再次被选中，因此yield()方法可能会不起作用(这也说明了yield()方法不会使得比当前线程优先级低的线程运行)。
java虚拟机中如果多个线程优先级相同，则会随机选择一个线程占用CPU，处于运行状态的线程会一直运行，直至它不得不放弃CPU为止，因此不一定是分时调度。

构建C程序需要4个步骤，分别使用4个工具完成： preprocessor(预处理程序), compiler(编译器), assembler(汇编器), and linker(链接器).四步完成后生成一个可执行文件。


第一步，预处理. 这一步处理 头文件、条件编译指令和宏定义。


第二步，编译. 将第一步产生的文件连同其他源文件一起编译成汇编代码。


第三步，汇编。将第二步产生的汇编源码转换为 object file.


第四步，链接. 将第三步产生的一些object file 链接成一个可执行的文件。

java中只有整型才能使用的运算符为%

++分为前置和后置，前置++比+运算优先级高，后置比+运算符优先级低。
++i > + > i++

equals（）比较的是字符串的内容，==比较的是内存地址值:
String s1="abc"+"def";//1
String s2=new String（s1);//2
if(s1.equals(s2))//3
System.out.println(".equals succeeded");//4
if(s1==s2)//5
System.out.println("==succeeded");//6
行4执行，行6不执行

面向对象语言的特性：封装，继承，多态

封装：隐藏对象的属性和实现细节，仅对外提供公共访问方式；
继承：让某种类型对象获得另一个类型对象的属性和方法；
多态：同一事物表现出不同事物的能力，即向不同对象发送同一消息，不同对象在接收时产生不同的行为（重载和模板实现编译时多态，虚函数实现运行时多态）。
封装和继承是为了代码重用，多态是为了接口重用

快速排序
思路分析：快速排序采用双向查找的策略，每一趟选择当前所有子序列中的一个关键字作为枢纽轴，将子序列中比枢纽轴小的前移，比枢纽轴大的后移，当本趟所有子序列都被枢轴按上述规则划分完毕后将会得到新的一组更短的子序列，他们将成为下趟划分的初始序列集。
时间复杂度：最好情况（待排序列接近无序）时间复杂度为O(nlog2n)，最坏情况（待排序列接近有序）时间复杂度为O(n2)，平均时间复杂度为O(nlog2n)。

二维数组必须指定列的数量，行的数量可以不指定

Hash处理冲突的方法：
1)开放地址法:线性探查法、平方探查法、伪随机序列法、双哈希函数法
2)拉链法:把所有同义词，即hash值相同的记录，用单链表连接起来
3)再哈希法
4)建立公共溢出区:把冲突的都放在另一个地方，不在表里面。

python 中没有max = x > y ? x : y

C 语言规定，在一个源程序中，main函数的位置（可以任意）

void main()
{char x=0xFFFF;printf ("%d\n",x--)；}//这里输出的是x，并不是x--
（负数用补码表示）
可以把它想象成无符号表示的整数，char占一个字节8 bit，范围0~255（0x0~0xff）
但是对于有符号整数来说，最高位为1意味着是负数所以从128~255（0x80~0xff）是负数，
因为（0xff+0x01=0x00）即-1+1=0所以0xff应该对应有符号整数-1，相应有0xfe对应-2，。。。。0x80对应-128
	
int k=3;
printf("%d",k++);//输出k，然后才 k++；

设有1000个无序的元素，希望用最快的速度挑选出其中前10个最大的元素，最好选用_______ 堆排序_______排序法。 
1. 建最大堆， 建堆的时间复杂度 O(n),
2. 每次取出最大元素， 并调整堆 时间复杂度为 O(logn)
3. 时间复杂度为 O（n + 10*logn）

稳定的排序：冒泡、插入、归并、计数、桶排序
不稳定排序：选择、快速、希尔、堆排序

前序 中序 后序    这三个两辆组合 必须要有中序才能唯一确定一棵二叉树     前与后 不能唯一确定  

什么是预处理指令?
预处理指令是以#号开头的代码行。#号必须是该行除了任何空白字符外的第一个字符。#后是指令关键字，在关键字和#号之间允许存在任意个数的空白字符。整行语句构成了一条预处理指令，该指令将在编译器进行编译之前对源代码做某些转换。
#空指令，无任何效果
#include包含一个源代码文件
#define定义宏
#undef取消已定义的宏
#if如果给定条件为真，则编译下面代码
#ifdef如果宏已经定义，则编译下面代码
#ifndef如果宏没有定义，则编译下面代码
#elif如果前面的#if给定条件不为真，当前条件为真，则编译下面代码
#endif结束一个#if……#else条件编译块
#error停止编译并显示错误信息

#if 0
///< 旧的代码(或函数) (旧的代码, 将会被预处理的时候,屏蔽掉, 不进行编译)
#else
///< 新的代码(或函数)
#endif
 
#ifndef JOE_DEBUG
///< 新的代码(或函数)
#else
///< 旧的代码(或函数) (旧的代码, 将会被预处理的时候,屏蔽掉, 不进行编译)
#endif
 
#ifdef Q_DEBUG
///< 新的代码(或函数)
#else
///< 旧的代码(或函数) (旧的代码, 将会被预处理的时候,屏蔽掉, 不进行编译)
#endif<br><br>

守护进程(daemon)是一类在后台运行的特殊进程，用于执行特定的系统任务。很多守护进程在系统引导的时候启动，并且一直运行直到系统关闭。另一些只在需要的时候才启动，完成任务后就自动结束。

二叉树不是树的特殊情形，其与度数为二的有序树也不同。在有序树中，若节点只有一个孩子，则无左右孩子之分，而二叉树则不同。

关于Linux系统的负载（Load）链接：三个数分别代表不同时间段的系统平均负载（一分钟、五分钟、以及十五分钟），它们的数字当然是越小越好。数字越高，说明服务器的负载越大，这也可能是服务器出现某种问题的信号。但是一分钟和五分钟的平均负载大于十五分钟的，不是负载在变小吧。

exit(0) 头文件#include <stdlib.h>
linux 编译c程序：
gcc -o test test.c
./test

#include <malloc.h>
int *p = (int *)malloc(sizeof(int))
(分配类型 *)malloc(分配元素个数 *sizeof(分配类型))
如果成功，则返回该空间首地址，该空间没有初始化，如果失败，则返回0

realloc?


char *lcf=(char *)realloc(p,256);
原型：extern void *realloc(void *mem_address, unsigned int newsize);?
? 用法：#include <stdlib.h> 有些编译器需要#include <alloc.h>?
? ? ? ?
功能：改变mem_address所指内存区域的大小为newsize长度。?
? ? ? ?
说明：如果重新分配成功则返回指向被分配内存的指针，否则返回空指针NULL。当内存不再使用时，应使用free()函数将内存块释放。?
? ? ? ?
注意：这里原始内存中的数据还是保持不变的。?

sizeof（）函数用法汇总
1. 与strlen()比较
    strlen计算字符数组的字符数，以“\0"为结束符，不计算“\0"为数组元素。
    sizeof（）计算数据（数组、变量、类型、结构体等）所占空间，用字节数表示。
2.指针与静态数组的sizeof操作
  指针均可看为变量类型的一种，所有指针变量的sizeof操作结果均为4 。（这个已实践证明）
 所以不要用下面的方式去计算一个字符数组的长度：
char *a= "nihaomao";
int count = sizeof(a);//返回值为4
而应该使用下面的方式计算：
char a[] = "nihaomao";
int count = sizeof(a);返回值为1*8=8
int a[10];
sizeof(a)则返回值为4*10=40 。

void *memset(void *s, int ch, size_t n);
函数解释：将s中当前位置后面的n个字节 （typedef unsigned int size_t ）用 ch 替换并返回 s 。
memset：作用是在一段内存块中填充某个给定的值，它是对较大的结构体或数组进行清零操作的一种最快方法 [1]  。
memset()函数原型是extern void *memset(void *buffer, int c, int count) buffer：为指针或是数组,c：是赋给buffer的值,count：是buffer的长度.

 const最主要的特点就是只读，有常量、常量指针，如果不是特别小心的分析C语言语句的书写格式，再加上指针的使用，就特别容易弄错。
    volatile关键字是一个类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问；如果不使用valatile，则编译器将对所声明的语句进行优化。之所以优化是因为访问寄存器要比访问内存单元快得多。但是优化之后容易出现问题，例如现在要直接对内存地址单元的内容修改，如果继续使用未经过valatile声明的变量，则读到的值有可能是寄存器中未经过修改的值，但本意是要读发生变化后的数值，所以会出现意想不到的错误。而经valatile声明的变量，每次访问该变量时都会从内存单元中重新读取。
   const经常用于声明不希望被其它程序修改的常量；volatile经常用于声明因意外而可能发生改变的变量
