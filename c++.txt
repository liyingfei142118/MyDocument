1.野指针:野指针就是指向无效地址的指针
概念：野指针指向了一块随机内存空间，不受程序控制。如指针指向已经被删除的对象或者指向一块没有访问权限的内存空间，之后如果对其再解引用的话，就会出现问题。
野指针产生的原因：
1、指针定义时未被初始化：指针在被定义的时候，如果程序不对其进行初始化的话，它会指向随机区域，因为任何指针变量（除了static修饰的指针变量）在被定义的时候是不会被置空的，它的默认值是随机的。
2、指针被释放时没有被置空：我们在用malloc开辟内存空间时，要检查返回值是否为空，如果为空，则开辟失败；如果不为空，则指针指向的是开辟的内存空间的首地址。指针指向的内存空间在用free()或者delete（注意delete只是一个操作符，而free()是一个函数）释放后，如果程序员没有对其置空或者其他的赋值操作，就会使其成为一个野指针。
3、指针操作超越变量作用域：不要返回指向栈内存的指针或引用，因为栈内存在函数结束的时候会被释放

野指针的危害：
野指针的问题在于，指针指向的内存已经无效了，而指针没有被置空，解引用一个非空的无效指针是一个未被定义的行为，也就是说不一定导致段错误，野指针很难定位到是哪里出现的问题，在哪里这个指针就失效了，不好查找出错的原因。所以调试起来会很麻烦，有时候会需要很长的时间。

规避方法
初始化指针时将其置为NULL，之后再对其进行操作。
释放指针时将其置为NULL，最好在编写代码时将free()函数封装一下，在调用free()后就将指针置为NULL。
要想彻底地避免野指针，最好的办法就是养成一个良好的编程习惯。

 浅拷贝只是复制了对象的引用地址，两个对象指向同一个内存地址，所以修改其中任意的值，另一个值都会随之变化，这就是浅拷贝（例：assign()）

深拷贝是将对象及值复制过来，两个对象修改其中任意的值另一个值不会改变，这就是深拷贝

在C语言中，修饰符extern用在变量或者函数的声明前，用来说明“此变量/函数是在别处定义的(其他文件里），要在此处引用”。


层次遍历创建二叉树
void insert(TreeNode *p, vector<int> temp, int t){
    int length = temp.size();
    if(t>=length)return;
    p->val = temp[t];
    if((2 * (t+1)) <= length){
        if(temp[2 * (t+1) -1]!=0){
            TreeNode *l;
            l = (TreeNode*)malloc(sizeof(TreeNode));
            l->left = NULL;
            l->right = NULL;
            p->left = l;
            insert(p->left, temp, 2 * (t+1) -1);
        }
        if((2 * (t+1) +1) <= length){
            if(temp[2 * (t+1)]!=0){
                TreeNode *r;
                r = (TreeNode*)malloc(sizeof(TreeNode));
                r->left = NULL;
                r->right = NULL;
                p->right = r;
                insert(p->right, temp, 2 * (t+1));
            }
        }
    }
}
 
TreeNode* createFromArray(vector<int> temp){
    TreeNode *p;
    p = (TreeNode*)malloc(sizeof(TreeNode));
    p->left = NULL;
    p->right = NULL;
    insert(p,temp,0);
    return p;
}

内存管理常用区间和区间中的数据
静态区(static): 存放（初始化的）全局变量、静态变量和(未初始化的)全局变量和静态变量；
栈区(stack): 存放局部变量和函数的形参。栈中的内存空间由编译器自动申请和释放。
堆区(heap): 存放动态分配内存函数申请的变量。堆中的内存空间需要程序员手动释放，否则会引发内存泄露。


一个字节8位
int 32位 4个字节
在32位机器中，假设在地址 0x100位置存储了一个int 值100，那么在0x103地址里面存的字节值用十进制表示是（4）	（32位机int 2字节，0x103保存第四位就是4） 
32位机器：每个地址放半字节
下面是（64位机器）：每个地址放一个字节	
10进制：100
2进制：0000 0000 0000 0000 0000 0000 0110 0100
16进制：0 0 0 0 0 0 6 4
地址    :  0x100 0x101 0x102 0x103
（大多IBM与Sun Microsystems的机器都采用这种规则）：大端方式
大端格式：  00    00     00    64(最低有效字节排列高地址的方式叫做小端法)
小端格式：  64    00     00    00(最低有效字节排列低地址的方式叫做小端法)

#include <iostream>
using namespace std;
int main(  )
{
    int x = 10;
    int& ref = x;
    ref = 20;
    cout << "x= " << x << endl;//10
    x = 30;
    cout << "ref=" << ref << endl;//30
}
C++中， &表示取别名，所以这里，x和ref实际上操作的是同一个对象

二叉树的中序和先序遍历分别是d b e a f c g和a b d e c f g。那么它的后序遍历是d e b f g c a